---
name: Generic
menu: Base
route: /base/generic
---

import { Playground } from "docz";

import {
  ComponentFeatures,
  SimplePropsTable,
  asDoc,
  mapEnumerable,
  refDoc,
} from "src/__docs__/components";
import { Generic } from "../generic";
import { DEFAULTS } from "../helpers/variables";
import { Notification, Table, Title } from "src/elements";

# Generic

This component apples standard _Bulma_ theming to any element or component.

<Playground>
  <Generic>
    <h2>
      Hello World, I'm a <code>{Generic.defaultProps.as}</code>
    </h2>
    <span>
      I'm a <code>{"<Generic>"}</code>, and by default I render as a{" "}
      <code>{Generic.defaultProps.as}</code>.
    </span>
  </Generic>
</Playground>

By changing the `as` prop (described in greater detail below), you can render a `<Generic>` component as any other component or JSX Element, as well as forward its props and a ref.

<Playground>
  <Generic as="nav">
    <h2>
      Hello World, I'm a <code>nav</code>
    </h2>
    <span>
      I'm a <code>{"<Generic>"}</code>, and I render as the JSX Element{" "}
      <code>p</code>.
    </span>
  </Generic>
</Playground>

Here is an example of rendering as a `<Notification>` component, and passing through its props:

<Playground>
  <Generic as={Notification} color="primary">
    <h2>Hello World</h2>
    <p>
      I'm a <code>{"<Generic>"}</code>, and I render as a{" "}
      <code>{"<Notification>"}</code>.
    </p>
  </Generic>
</Playground>

## API

<ComponentFeatures asType={Generic.defaultProps.as} />

### Core properties

<SimplePropsTable
  props={{
    as: {
      ...asDoc,
      defaultValue: Generic.defaultProps.as,
    },
    ref: refDoc,
  }}
/>

### Float properties

<SimplePropsTable
  props={{
    clearfix: {
      description: "fixes an element's floating children",
      typeName: "boolean",
    },
    pull: {
      description: "moves an element to the left or right",
      typeName: "string (literal)",
      typeTip: mapEnumerable(DEFAULTS.floatPulledAlignments),
    },
  }}
/>

### Overflow properties

<SimplePropsTable
  props={{
    clipped: {
      description: "adds overflow hidden",
      typeName: "boolean",
    },
  }}
/>

### Overlay properties

<SimplePropsTable
  props={{
    overlay: {
      description: "completely covers the first positioned parent",
      typeName: "boolean",
    },
  }}
/>

### Typography properties

<SimplePropsTable
  props={{
    backgroundColor: {
      description: "sets the background color",
      typeName: "string (literal)",
      typeTip: mapEnumerable([...DEFAULTS.colors, ...DEFAULTS.shades]),
    },
    italic: {
      description: "makes the text italic",
      typeName: "boolean",
    },
    textAlign: {
      description: "sets the alignment of the text",
      typeName: "string (literal)",
      typeTip: mapEnumerable(DEFAULTS.textAlignments),
    },
    textColor: {
      description: "sets the text color",
      typeName: "string (literal)",
      typeTip: mapEnumerable([...DEFAULTS.colors, ...DEFAULTS.shades]),
    },
    textSize: {
      description: "sets the text size",
      typeName: "number (literal)",
      typeTip: mapEnumerable(DEFAULTS.textSizes),
    },
    textTransform: {
      description: "alters the text capitalization",
      typeName: "string (literal)",
      typeTip: mapEnumerable(DEFAULTS.textSizes),
    },
    textWeight: {
      description: "sets the text weight",
      typeName: "string (literal)",
      typeTip: mapEnumerable(DEFAULTS.textWeights),
    },
  }}
/>

### Visibility properties

<SimplePropsTable
  props={{
    hidden: {
      description: "hides the element",
      typeName: "boolean",
    },
    invisible: {
      description: "adds visibility hidden",
      typeName: "boolean",
    },
    srOnly: {
      description:
        "Hide elements visually but keeps the element available to be announced by a screen reader",
      typeName: "boolean",
    },
  }}
/>

### Other properties

<SimplePropsTable
  props={{
    marginless: {
      description: "removes any margin",
      typeName: "boolean",
    },
    paddingless: {
      description: "removes any padding",
      typeName: "boolean",
    },
    radiusless: {
      description: "removes any radius",
      typeName: "boolean",
    },
    relative: {
      description: "applies position: relative to the element",
      typeName: "boolean",
    },
    shadowless: {
      description: "removes any shadow",
      typeName: "boolean",
    },
    unselectable: {
      description: "prevents the text from being selectable",
      typeName: "boolean",
    },
  }}
/>

### Responsive properties

<SimplePropsTable
  props={{
    responsive: {
      description:
        "a mapping of breakpoints to Responsive or LimitedResponsive objects",
      typeName: "{ [Responsive Key]?: <Responsive> | <LimitedResponsive> }",
    },
  }}
/>

<Notification>
  <Title as="h5" size={5}>Responsive Object & LimitedResponsive Object</Title>
  <div>
    <p>
      The <strong>Responsive Object</strong> has the following structure:
    </p>
    <pre
      children={JSON.stringify(
        {
          display: {
            only: "boolean",
            value: mapEnumerable(DEFAULTS.displays).replace(/["]/g, "'"),
          },
          hide: {
            only: "boolean",
            value: "boolean",
          },
          textAlign: {
            only: "boolean",
            value: mapEnumerable(DEFAULTS.textAlignments).replace(/["]/g, "'"),
          },
          textSize: {
            only: "boolean",
            value: mapEnumerable(DEFAULTS.textSizes).replace(/["]/g, "'"),
          },
        },
        null,
        2,
      ).replace(/["]/g, "")}
    />
    <br />
  </div>

  <Title as="h5" size={5}>
    <code>responsive</code> keys
  </Title>
  <p>
    By default, these are the keys and sizes supplied by Bulma.
    You can customize them by overriding variables in the Bulma sass.
  </p>
  <Table bordered narrow striped fullwidth>
    <Table.Head>
      <Table.Row>
        <Table.Heading>key</Table.Heading>
        <Table.Heading>value type</Table.Heading>
        <Table.Heading>description</Table.Heading>
      </Table.Row>
    </Table.Head>
    <Table.Body>
      <Table.Row>
        <Table.Cell><code>mobile</code></Table.Cell>
        <Table.Cell><code>LimitedResponsive</code> object</Table.Cell>
        <Table.Cell>up to <code>768px</code></Table.Cell>
      </Table.Row>

      <Table.Row>
        <Table.Cell><code>tablet</code></Table.Cell>
        <Table.Cell><code>Responsive</code> object</Table.Cell>
        <Table.Cell>between<code>769px</code> and <code>1023px</code></Table.Cell>
      </Table.Row>

      <Table.Row>
        <Table.Cell><code>touch</code></Table.Cell>
        <Table.Cell><code>LimitedResponsive</code> object</Table.Cell>
        <Table.Cell>up to <code>1023px</code> (in place of <code>mobile</code> or <code>tablet</code>)</Table.Cell>
      </Table.Row>

      <Table.Row>
        <Table.Cell><code>desktop</code></Table.Cell>
        <Table.Cell><code>Responsive</code> object</Table.Cell>
        <Table.Cell>between<code>1024px</code> and <code>1215px</code></Table.Cell>
      </Table.Row>

      <Table.Row>
        <Table.Cell><code>widescreen</code></Table.Cell>
        <Table.Cell><code>Responsive</code> object</Table.Cell>
        <Table.Cell>between<code>1216px</code> and <code>1407px</code></Table.Cell>
      </Table.Row>

      <Table.Row>
        <Table.Cell><code>fullhd</code></Table.Cell>
        <Table.Cell><code>LimitedResponsive</code> object</Table.Cell>
        <Table.Cell><code>1408px</code> and above</Table.Cell>
      </Table.Row>
    </Table.Body>

  </Table>

  <p>
    A simple example of this prop value might look like this:
  </p>
  <pre
    children={JSON.stringify(
      {
        touch: { hide: { value: true } },
        desktop: { display: { only: true, value: "'block'" }}
      },
      null,
      2,
    ).replace(/["]/g, "")}
  />

  <Title as="h5" size={5}>
    display
  </Title>
  <p>
    <code>display.value</code> specifies – for a specific breakpoint – the
    display style of the text and is <strong>required</strong>.
    <code>display.only</code> specifies if it should also be applied to bigger breakpoints.
  </p>

  <br />
  <Title as="h5" size={5}>
    hide
  </Title>
  <p>
    <code>hide.value</code> specifies – for a specific breakpoint – whether the
    element should be hidden and is <strong>required</strong>.
    <code>hide.only</code> specifies if it should also be applied to bigger breakpoints.
  </p>

  <br />
  <Title as="h5" size={5}>
    textAlign
  </Title>
  <p>
    <code>textAlign.value</code> specifies – for a specific breakpoint – the
    alignment of the text and is <strong>required</strong>. <code>textAlign.only</code> specifies if it
    should also be applied to bigger breakpoints.
  </p>

  <br />
  <Title as="h5" size={5}>
    textSize
  </Title>
  <p>
    <code>textSize.value</code> specifies – for a specific breakpoint – the size
    of the text and is <strong>required</strong>. <code>textSize.only</code> specifies if it should also be
    applied to bigger breakpoints.
  </p>

  <br />
  <Generic as="p" textColor="info">
    The only difference between the <strong>Responsive Object</strong> and the{" "}
    <strong>LimitedResponsive Object</strong>, is that the latter does not permit
    the <code>only</code> property, as it semantically does not apply.
  </Generic>

</Notification>
